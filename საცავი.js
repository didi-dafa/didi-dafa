var ფს=require('fs')
var ნახაზი=require('canvas')

var ნახაზები={}
var ფრაგმენტის_ხ=1024, ფრაგმენტის_ჯ=1024

function გაათეთრე(ნახაზი){
    var კონტ=ნახაზი.getContext("2d");
    კონტ.fillStyle="#FFFFFF";
    კონტ.fillRect(0,0,ნახაზი.width, ნახაზი.height)
}

function მომე_მოზომილი_ფრაგმენტი(ხ, ჯ, შიდა, უკუძახილი){
    var სახელი = Math.floor(ხ/ფრაგმენტის_ხ)+'.'+Math.floor(ჯ/ფრაგმენტის_ჯ)
    var ნახ=ნახაზები[სახელი]
    if(ნახ){
        უკუძახილი(ნახ, შიდა)
        return
    }
    
    // ახალი ჩანაწერის მომზადება
    ნახ=new ნახაზი(ფრაგმენტის_ხ,ფრაგმენტის_ჯ)
    გაათეთრე(ნახ)
    ნახ.სახელი=სახელი
    ნახ.ხ=Math.floor(ხ/ფრაგმენტის_ხ)*ფრაგმენტის_ხ
    ნახ.ჯ=Math.floor(ჯ/ფრაგმენტის_ჯ)*ფრაგმენტის_ჯ
    ნახ.ჩასაწერი=false
        
    ფს.exists('საცავი/'+სახელი, function(არსებობს){
        if(!არსებობს){
            ნახაზები[სახელი]=ნახ
            უკუძახილი(ნახ, შიდა)
            return
        }
        ფს.readFile('საცავი/'+სახელი, function(შეც, შიგთავსი){
            if(შეც) { console.log(შეც); return }
            ნახაზები[სახელი]=ნახ
            var სურ = new ნახაზი.Image
            სურ.src=შიგთავსი
            ნახ.drawImage(სურ, 0, 0, ფრაგმენტის_ხ, ფრაგმენტის_ჯ)
            უკუძახილი(ნახ, შიდა)
        })
    })
    
}

function მომე_შესაცვლელი_ფრაგმენტები(ნაქნარი1, ნაქნარი2, უკუძახილი){
    მომე_მოზომილი_ფრაგმენტი(ნაქნარი1.ხ, ნაქნარი1.ჯ, null, function(ნახ1){
        მომე_მოზომილი_ფრაგმენტი(ნაქნარი2.ხ, ნაქნარი2.ჯ, null, function(ნახ2){
            if(ნახ1==ნახ2){
                უკუძახილი([ნახ1], ნაქნარი1, ნაქნარი2)
            }else{
                უკუძახილი([ნახ1, ნახ2], ნაქნარი1, ნაქნარი2)
            }
        })
    })
}

exports.მიახატე=function(ნაქნარი){
    for(var ი=1;ი<ნაქნარი.გზა.length;ი++){
        var ნაქ=ნაქნარი.გზა[ი]
        var წინა_ნაქ=ნაქნარი.გზა[ი-1]
        
        მომე_შესაცვლელი_ფრაგმენტები(ნაქ, წინა_ნაქ, function(ფრაგმენტები, ნაქ1, წინა_ნაქ1){
            for(var ფ in ფრაგმენტები){
                var ფრაგმენტი = ფრაგმენტები[ფ]
                
                var ხ=ნაქ1.ხ-ფრაგმენტი.ხ,
                    ჯ=ნაქ1.ჯ-ფრაგმენტი.ჯ,
                    წინა_ხ=წინა_ნაქ1.ხ-ფრაგმენტი.ხ,
                    წინა_ჯ=წინა_ნაქ1.ჯ-ფრაგმენტი.ჯ
                    
                var კონტ = ფრაგმენტი.getContext('2d')
                
                კონტ.moveTo(წინა_ხ,წინა_ჯ)
                კონტ.lineTo(ხ,ჯ)
                კონტ.stroke()
                ფრაგმენტი.ჩასაწერი=true
            }
        })
    }
}

exports.მომე_ფრაგმენტი=function(ხ,ჯ,სიგანე,სიმაღლე, უკუძახილი){
    var ნახ=new ნახაზი(სიგანე, სიმაღლე),
        კონტ=ნახ.getContext('2d'),
        ხ_ნაბიჯები = Math.floor(სიგანე/ფრაგმენტის_ხ)+2,
        ჯ_ნაბიჯები = Math.floor(სიგანე/ფრაგმენტის_ჯ)+2
        
    var წყობა={}
    for(var ი=0;ი<ხ_ნაბიჯები;ი++){
        for(var კ=0;კ<ჯ_ნაბიჯები;კ++){
            მომე_მოზომილი_ფრაგმენტი(ხ+ი*ფრაგმენტის_ხ, ჯ+კ*ფრაგმენტის_ჯ, 
            {ი:ი,კ:კ,ხ:ხ,ჯ:ჯ,სიგანე:სიგანე,სიმაღლე:სიმაღლე, ნაბიჯები:ი+კ}, 
            function(ფრაგ, შიდა){
                function გადადი_თუ_ბოლოა(){
                    if(შიდა.ნაბიჯები==ხ_ნაბიჯები+ჯ_ნაბიჯები-2){
                        ჩახატე_ნაგროვები()
                    }
                }
                // თუ ეს უჯრა საერთოდ არ მონაწილეობს საქმეში, მაშინ გამოვრიცხოთ
                if(შიდა.ხ+შიდა.სიგანე<ფრაგ.ხ||
                        შიდა.ჯ+შიდა.სიმაღლე<ფრაგ.ჯ||
                        შიდა.ხ>ფრაგ.ხ+ფრაგმენტის_ხ||
                        შიდა.ჯ>ფრაგ.ჯ+ფრაგმენტის_ჯ){
                    გადადი_თუ_ბოლოა()
                    return
                }
                // მოსაჭრელი ოთხკუთხედის წერტილების შერჩევა
                var ა=0,ბ=0,გან=შიდა.სიგანე,მაღ=შიდა.სიმაღლე
                
                // აქ პირობებია ამოჭრილი იმის გათვალისწინებით, რომ 
                // მანამდე არასაჭირო ნაჭრები იფილტრება და 
                // მაგალითად ხ>ფრაგ.ხ+ფრაგმენტის_ხ ვარიანტი არასდროს ამოვა.
                
                if(შიდა.ხ>=ფრაგ.ხ){
                    // თუ ხ წერტილი ფრაგმენტშია
                    ა=შიდა.ხ-ფრაგ.ხ
                    if(ა+შიდა.სიგანე>=ფრაგმენტის_ხ){
                        // თუ სიგანე საზღვარს გასცდა
                        გან=ფრაგმენტის_ხ-ა
                    }
                }else{
                    // თუ ფრაგმენტამდეა
                    გან=შიდა.სიგანე-(ფრაგ.ხ-შიდა.ხ)
                    if(გან>ფრაგმენტის_ხ){
                        გან=ფრაგმენტის_ხ
                    }
                }
                
                if(შიდა.ჯ>=ფრაგ.ჯ){
                    ბ=შიდა.ჯ-ფრაგ.ჯ
                    if(ბ+შიდა.სიმაღლე>=ფრაგმენტის_ჯ){
                        მაღ=ფრაგმენტის_ჯ-ბ
                    }
                }else{
                    მაღ=შიდა.სიმაღლე-(ფრაგ.ჯ-შიდა.ჯ)
                    if(მაღ>ფრაგმენტის_ჯ){
                        მაღ=ფრაგმენტის_ჯ
                    }
                }
                
                console.log(ფრაგ.სახელი, ა, ბ, გან, მაღ)
                
                წყობა[შიდა.ი*ხ_ნაბიჯები+შიდა.კ]={
                    ა:ა,
                    ბ:ბ,
                    გან:გან,
                    მაღ:მაღ,
                    ფრაგ:ფრაგ,
                    ფრაგ_სახ:ფრაგ.სახელი
                }
                
                გადადი_თუ_ბოლოა()
            })
        }
    }
    
    function ჩახატე_ნაგროვები(){
        var მდებარეობა_ხ=0, მდებარეობა_ჯ=0
        
        for(var ი=0;ი<ხ_ნაბიჯები*ჯ_ნაბიჯები;ი++){
            var წყობ=წყობა[ი]
            if(!წყობ){
                continue
            }
            კონტ.drawImage(წყობ.ფრაგ,წყობ.ა,წყობ.ბ,წყობ.გან,წყობ.მაღ,
                    მდებარეობა_ხ, მდებარეობა_ჯ, წყობ.გან,წყობ.მაღ)
            მდებარეობა_ჯ+=წყობ.მაღ
            if(მდებარეობა_ჯ>=სიმაღლე){
                მდებარეობა_ხ+=წყობ.გან
                მდებარეობა_ჯ=0
            }
        }
        
        ნახ.toBuffer(function(შეც, ინფო){
            if(შეც){ console.log(შეც); return }
            უკუძახილი(ინფო)
        })
    }
} 
